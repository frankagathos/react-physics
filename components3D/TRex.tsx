/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 tRex.glb --transform
*/

import React, { useRef, useEffect } from 'react'
import * as THREE from 'three'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useSphere } from '@react-three/cannon'
import usePersonControls from '../hooks/usePersonControls'
import { useFrame } from '@react-three/fiber'

export function TRexModel({ run, ...restProps }: any) {
  const { nodes, materials, animations } = useGLTF('../tRex-transformed.glb')
  const modelRef = useRef<any>(null)
  const [sphereRef, api] = useSphere(() => ({
    mass: 1000,
    position: [0, 0.5, 0],
    type: 'Dynamic',
  }))

  const SPEED = 5

  const { actions } = useAnimations(animations, modelRef)
  const { forward, backward, right, left } = usePersonControls()

  useFrame(() => {
    if (actions && actions.idle && actions.run) {
      if (forward) {
        actions.idle.stop()
        actions.run.play()
      } else {
        actions.run.stop()
        actions.idle.play()
        // actions.run.fadeOut(1)
        // actions.idle.fadeIn(1)
      }
      // if (movement.backward) {
      //   actions.run.crossFadeTo(actions.idle, 50, true)
      //   ref.current.position.x -= 0.01
      // }
      // if (movement.right) {
      //   console.log('TEST')
      //   ref.current.rotation.y += Math.PI / 180
      // }
      // if (Object.values(movement).every((m) => m === false)) {
      //   console.log('ACTIONS', actions)
      //   // actions?.idle?.play()
      //   actions.run.crossFadeTo(actions.idle, 0.5, false)
      // }
    }

    // Calculating front/side movement ...
    let frontVector = new THREE.Vector3(0, 0, 0)
    let sideVector = new THREE.Vector3(0, 0, 0)
    let direction = new THREE.Vector3(0, 0, 0)

    frontVector.set(0, 0, Number(forward) - Number(backward))
    sideVector.set(Number(right) - Number(left), 0, 0)
    direction
      .subVectors(frontVector, sideVector)
      .normalize()
      .multiplyScalar(SPEED)

    api.velocity.set(direction.x, 0, direction.z)

    if (sphereRef.current) {
      sphereRef.current.getWorldPosition(modelRef.current.position)
    }
  })

  // useEffect(() => {
  //   //Set init position and rotation
  //   if (modelRef.current) {
  //     modelRef.current.rotation.y = Math.PI / 2
  //     modelRef.current.position.y = 0.5
  //   }
  // }, [])

  return (
    <group ref={modelRef} {...restProps} dispose={null}>
      <group>
        <group name="RootNode0" scale={0.01}>
          <group name="geo1">
            <skinnedMesh
              name="TRex2"
              //@ts-ignore
              geometry={nodes.TRex2.geometry}
              //@ts-ignore
              material={nodes.TRex2.material}
              //@ts-ignore
              skeleton={nodes.TRex2.skeleton}
            />
          </group>
          <group name="skeletal3">
            <primitive object={nodes.bn_Spine4} />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('../tRex-transformed.glb')
